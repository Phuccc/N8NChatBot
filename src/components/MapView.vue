<template>
  <div class="map-wrapper bg-slate-800 rounded-lg overflow-hidden flex flex-col h-full">
    <div
      class="p-4 font-bold text-xl bg-gradient-to-r from-cyan-600 to-blue-600 text-white shadow-md flex items-center">
      <div class="text-cyan-300 mr-3 text-2xl">üó∫Ô∏è</div>
      <div>B·∫£n ƒë·ªì √î nhi·ªÖm</div>
    </div>

    <div class="relative flex-grow">
      <div id="map" class="map-container w-full h-full z-0"></div>

      <!-- Toggle button for legend -->
      <div class="absolute bottom-4 right-4 z-10">
        <!-- Collapsed legend button -->
        <button v-if="!legendExpanded" @click="toggleLegend"
          class="flex items-center justify-center w-12 h-12 rounded-full bg-slate-800 border border-slate-600 shadow-lg hover:bg-slate-700 transition-all duration-300">
          <span class="text-cyan-300 text-xl">‚â°</span>
        </button>

        <!-- Expanded legend -->
        <div v-else class="bg-slate-800 bg-opacity-90 rounded-lg p-3 border border-slate-600 shadow-lg w-48">
          <div class="flex justify-between items-center text-cyan-300 font-bold mb-2 text-lg">
            <div class="flex items-center">
              <span class="mr-2">üìå</span> Ch√∫ th√≠ch AQI
            </div>
            <button @click="toggleLegend" class="text-cyan-300 hover:text-cyan-100 focus:outline-none">
              <span class="text-xl leading-none">&times;</span>
            </button>
          </div>
          <div class="space-y-2 text-sm">
            <div class="flex items-center">
              <span class="w-3 h-3 rounded-sm bg-green-500 mr-2"></span>
              <span class="text-white">T·ªët (0-50)</span>
            </div>
            <div class="flex items-center">
              <span class="w-3 h-3 rounded-sm bg-yellow-400 mr-2"></span>
              <span class="text-white">Trung b√¨nh (51-100)</span>
            </div>
            <div class="flex items-center">
              <span class="w-3 h-3 rounded-sm bg-orange-500 mr-2"></span>
              <span class="text-white">K√©m (101-150)</span>
            </div>
            <div class="flex items-center">
              <span class="w-3 h-3 rounded-sm bg-red-500 mr-2"></span>
              <span class="text-white">X·∫•u (151-200)</span>
            </div>
            <div class="flex items-center">
              <span class="w-3 h-3 rounded-sm bg-purple-600 mr-2"></span>
              <span class="text-white">Nguy h·∫°i (>200)</span>
            </div>
            <div class="flex items-center">
              <span class="w-3 h-3 rounded-sm bg-gray-400 mr-2"></span>
              <span class="text-white">Kh√¥ng c√≥ d·ªØ li·ªáu</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Th√™m khu v·ª±c hi·ªÉn th·ªã ch·ªâ s·ªë kh√¥ng kh√≠ ·ªü ph√≠a d∆∞·ªõi b·∫£n ƒë·ªì -->
    <div class="flex bg-white text-slate-800 p-4 shadow-inner">
      <div class="flex-1 flex flex-col items-center justify-center border-r border-slate-200">
        <div class="text-3xl font-bold text-blue-600">{{ currentCity }}</div>
        <div class="text-sm text-slate-500">Th√†nh ph·ªë</div>
      </div>
      <div class="flex-1 flex flex-col items-center justify-center border-r border-slate-200">
        <div class="text-4xl font-bold" :class="getAQIColor(currentAQI)">{{ currentAQI }}</div>
        <div class="text-sm text-slate-500">AQI</div>
      </div>
      <div class="flex-1 flex flex-col items-center justify-center">
        <div class="text-xl font-medium" :class="getAQIColor(currentAQI)">{{ getAQIDescription(currentAQI) }}</div>
        <div class="text-sm text-slate-500">T√¨nh tr·∫°ng</div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, computed } from 'vue'
import { useMapStore } from '@/stores/mapStore'
import { watch } from 'vue'
import L from 'leaflet'
import 'leaflet/dist/leaflet.css'
import geoData from '@/assets/gis_quan_HN_HCM.json'

// Initialize the map store
const mapStore = useMapStore()

const legendExpanded = ref(false)
const currentCity = ref('H√† N·ªôi')
const currentAQI = ref(132)
const map = ref(null)
const geoLayer = ref(null)

// Computed property to access location data from the store
const locationData = computed(() => {
  if (!mapStore.hasData) return {}

  // Create a map object with location names as keys
  const dataMap = {}
  mapStore.locations.forEach((location, index) => {
    dataMap[location] = {
      AQI: mapStore.AQI[index],
      CO: mapStore.CO[index],
      SO2: mapStore.SO2[index],
      PM25: mapStore.PM25[index]
    }
  })

  return dataMap
})

function toggleLegend() {
  legendExpanded.value = !legendExpanded.value
}

// L·∫•y m√†u d·ª±a tr√™n ch·ªâ s·ªë AQI cho ph·∫ßn hi·ªÉn th·ªã ·ªü d∆∞·ªõi
function getAQIColor(aqi) {
  if (aqi <= 50) return 'text-green-500'
  if (aqi <= 100) return 'text-yellow-500'
  if (aqi <= 150) return 'text-orange-500'
  if (aqi <= 200) return 'text-red-500'
  if (aqi > 200) return 'text-purple-600'
  return 'text-gray-400'
}

// L·∫•y m√¥ t·∫£ t√¨nh tr·∫°ng d·ª±a tr√™n ch·ªâ s·ªë AQI
function getAQIDescription(aqi) {
  if (aqi <= 50) return 'T·ªët'
  if (aqi <= 100) return 'Trung b√¨nh'
  if (aqi <= 150) return 'K√©m'
  if (aqi <= 200) return 'X·∫•u'
  if (aqi > 200) return 'Nguy h·∫°i'
  return 'Kh√¥ng c√≥ d·ªØ li·ªáu'
}

function getColor(aqi) {
  if (aqi === undefined || aqi === null) return '#9ca3af' // gray-400 cho kh√¥ng c√≥ d·ªØ li·ªáu
  if (aqi <= 50) return '#10b981' // green-500
  if (aqi <= 100) return '#facc15' // yellow-400
  if (aqi <= 150) return '#f97316' // orange-500
  if (aqi <= 200) return '#ef4444' // red-500
  if (aqi > 200) return '#9333ea' // purple-600
  return '#9ca3af' // fallback gray-400
}

// Function to calculate the centroid of a polygon or multipolygon
function getCentroid(feature) {
  let coords = []
  if (feature.geometry.type === 'Polygon') {
    coords = feature.geometry.coordinates[0]
  } else if (feature.geometry.type === 'MultiPolygon') {
    coords = feature.geometry.coordinates[0][0] // Use first polygon for simplicity
  }

  let latSum = 0, lngSum = 0, count = 0
  coords.forEach(coord => {
    latSum += coord[1]
    lngSum += coord[0]
    count++
  })

  return [latSum / count, lngSum / count]
}

// Function to update the map with new data
function updateMap() {
  if (!map.value || !geoLayer.value) return

  // Get the current city from store
  const city = mapStore.city

  // Update current city display
  currentCity.value = city || 'H√† N·ªôi'

  // If there's a most polluted location, show its AQI
  if (mapStore.mostPollutedLocation) {
    currentAQI.value = mapStore.mostPollutedLocation.AQI
  }

  // Filter GeoJSON based on selected city
  let cityFeatures = []
  if (city === 'H√† N·ªôi') {
    cityFeatures = geoData.features.filter(feature =>
      feature.properties.NAME_1 === 'H√† N·ªôi')
  } else if (city === 'H·ªì Ch√≠ Minh') {
    cityFeatures = geoData.features.filter(feature =>
      feature.properties.NAME_1 === 'H·ªì Ch√≠ Minh')
  } else {
    // Default to H√† N·ªôi if no city is specified
    cityFeatures = geoData.features.filter(feature =>
      feature.properties.NAME_1 === 'H√† N·ªôi')
  }

  // Update the GeoJSON layer with filtered data
  geoLayer.value.clearLayers()

  const filteredGeoData = {
    ...geoData,
    features: cityFeatures
  }

  geoLayer.value.addData(filteredGeoData)

  // Fit map to the city's bounds
  const bounds = geoLayer.value.getBounds()
  map.value.fitBounds(bounds, {
    padding: [50, 50],
    maxZoom: 11
  })
}

// Watch for changes in the map store
watch(() => mapStore.city, (newCity) => {
  if (newCity) {
    console.log('Updating map for city:', newCity)
    updateMap()
  }
})

// Watch locationData ƒë·ªÉ c·∫≠p nh·∫≠t m√†u khi d·ªØ li·ªáu ƒë·ªïi
watch(locationData, () => {
  if (geoLayer.value) {
    geoLayer.value.setStyle(feature => {
      const name = feature.properties.NAME_2
      const data = locationData.value[name]
      const aqi = data?.AQI
      return {
        fillColor: getColor(aqi),
        weight: 1.5,
        color: '#1e293b',
        fillOpacity: 0.8
      }
    })

    // C·∫≠p nh·∫≠t l·∫°i tooltip cho t·ª´ng layer
    geoLayer.value.eachLayer(layer => {
      const feature = layer.feature
      const name = feature.properties.NAME_2
      const data = locationData.value[name]
      const centroid = getCentroid(feature)
      const tooltipContent = data
        ? `<div style="font-family: 'Inter', sans-serif;">
             <div style="font-weight: bold; font-size: 16px; text-align: center; margin-bottom: 5px; color: #22d3ee;">${name}</div>
             <div style="padding: 5px; background: rgba(15, 23, 42, 0.7); border-radius: 4px;">
               <div>AQI: <span style="font-weight: bold; color: ${getColor(data.AQI)};">${data.AQI}</span></div>
               <div>CO: ${data.CO} ppm</div>
               <div>SO‚ÇÇ: ${data.SO2} ¬µg/m¬≥</div>
               <div>PM2.5: ${data.PM25} ¬µg/m¬≥</div>
             </div>
           </div>`
        : `<div style="font-family: 'Inter', sans-serif;">
             <div style="font-weight: bold; font-size: 16px; text-align: center; color: #22d3ee;">${name}</div>
             <div style="padding: 5px;">Kh√¥ng c√≥ d·ªØ li·ªáu</div>
           </div>`

      // X√≥a tooltip c≈© v√† g√°n tooltip m·ªõi
      layer.unbindTooltip()
      const tooltip = L.tooltip({
        permanent: false,
        direction: 'top',
        offset: [0, -20],
        opacity: 0.95,
        className: 'custom-tooltip'
      })
        .setContent(tooltipContent)
        .setLatLng(centroid)
      layer.bindTooltip(tooltip)
    })
  }
}, { deep: true })

onMounted(() => {
  // Need to wait a bit for the DOM to be fully rendered
  setTimeout(() => {
    // Initialize the map
    map.value = L.map('map', {
      zoomControl: false,
      attributionControl: false
    }).setView([21.0285, 105.8542], 11)

    // Set minimum zoom level to prevent zooming out too far
    map.value.setMinZoom(10)

    // Use a dark theme tile layer
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '¬© OpenStreetMap & CartoDB',
      subdomains: 'abcd',
      maxZoom: 19
    }).addTo(map.value);

    // Create a shadow pane for highlight effect
    map.value.createPane('shadowPane')
    map.value.getPane('shadowPane').style.zIndex = 450

    // Filter GeoJSON to include only H√† N·ªôi districts initially
    const hanoiFeatures = geoData.features.filter(feature => feature.properties.NAME_1 === 'H√† N·ªôi')
    const filteredGeoData = {
      ...geoData,
      features: hanoiFeatures
    }

    // Create GeoJSON layer
    geoLayer.value = L.geoJSON(filteredGeoData, {
      style: feature => {
        const name = feature.properties.NAME_2
        const data = locationData.value[name]
        const aqi = data?.AQI || null
        return {
          fillColor: getColor(aqi),
          weight: 1.5,
          color: '#1e293b', // slate-800
          fillOpacity: 0.8
        }
      },
      onEachFeature: (feature, layer) => {
        const name = feature.properties.NAME_2
        const data = locationData.value[name]
        const centroid = getCentroid(feature)
        const tooltipContent = data
          ? `<div style="font-family: 'Inter', sans-serif;">
             <div style="font-weight: bold; font-size: 16px; text-align: center; margin-bottom: 5px; color: #22d3ee;">${name}</div>
             <div style="padding: 5px; background: rgba(15, 23, 42, 0.7); border-radius: 4px;">
               <div>AQI: <span style="font-weight: bold; color: ${getColor(data.AQI)};">${data.AQI}</span></div>
               <div>CO: ${data.CO} ppm</div>
               <div>SO‚ÇÇ: ${data.SO2} ¬µg/m¬≥</div>
               <div>PM2.5: ${data.PM25} ¬µg/m¬≥</div>
             </div>
           </div>`
          : `<div style="font-family: 'Inter', sans-serif;">
             <div style="font-weight: bold; font-size: 16px; text-align: center; color: #22d3ee;">${name}</div>
             <div style="padding: 5px;">Kh√¥ng c√≥ d·ªØ li·ªáu</div>
           </div>`

        // Bind tooltip to the centroid of the district
        const tooltip = L.tooltip({
          permanent: false,
          direction: 'top',
          offset: [0, -20],
          opacity: 0.95,
          className: 'custom-tooltip'
        })
          .setContent(tooltipContent)
          .setLatLng(centroid)

        layer.bindTooltip(tooltip)

        // Show/hide tooltip on hover and update city info
        layer.on({
          mouseover: () => {
            layer.setStyle({
              weight: 3,
              color: '#0ea5e9', // sky-500
              fillOpacity: 0.9
            })
            layer.bringToFront()
            layer.openTooltip()

            // Update current location info when hovering
            if (data) {
              currentCity.value = name
              currentAQI.value = data.AQI
            }
          },
          mouseout: () => {
            geoLayer.value.resetStyle(layer)
            layer.closeTooltip()

            // Reset to default info when not hovering
            currentCity.value = mapStore.city || 'H√† N·ªôi'
            if (mapStore.mostPollutedLocation) {
              currentAQI.value = mapStore.mostPollutedLocation.AQI
            } else {
              currentAQI.value = 132 // Default value
            }
          },
          click: () => {
            map.value.fitBounds(layer.getBounds(), {
              padding: [50, 50],
              maxZoom: 12
            })

            // Update current location info when clicking
            if (data) {
              currentCity.value = name
              currentAQI.value = data.AQI
            }
          }
        })
      },
      pane: 'shadowPane'
    }).addTo(map.value)

    // Fit map to H√† N·ªôi districts' bounds
    const bounds = geoLayer.value.getBounds()
    map.value.fitBounds(bounds, {
      padding: [50, 50],
      maxZoom: 11
    })

    // Force map to update its size
    map.value.invalidateSize()
  }, 100)
})
</script>

<style scoped>
.map-wrapper {
  height: 100%;
  width: 100%;
}

.map-container {
  background-color: #0f172a;
  /* slate-900 */
  min-height: 380px;
  /* gi·∫£m m·ªôt ch√∫t chi·ªÅu cao ƒë·ªÉ ch·ª´a ch·ªó cho ph·∫ßn th√¥ng tin ·ªü d∆∞·ªõi */
}

/* Animation for legend toggle */
button {
  transition: all 0.3s ease;
}

button:hover {
  transform: scale(1.05);
}

/* Transition effect for the legend */
.absolute {
  transition: all 0.3s ease-in-out;
}

:global(.custom-tooltip) {
  background-color: #1e293b;
  /* slate-800 */
  color: #f1f5f9;
  /* slate-100 */
  font-size: 14px;
  padding: 8px;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
  border: 1px solid #334155;
  /* slate-600 */
}

:global(.leaflet-tooltip.custom-tooltip::before) {
  border-top-color: #1e293b;
  /* slate-800 */
}

:global(.leaflet-control-container .leaflet-control) {
  background-color: #1e293b;
  /* slate-800 */
  color: #f1f5f9;
  /* slate-100 */
  border: 1px solid #334155;
  /* slate-600 */
}

/* Fix for empty space issue */
:global(.leaflet-container) {
  height: 100%;
  width: 100%;
}
</style>
